//===-- AVRInstrInfo.td - AVR Instruction defs -------------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes the AVR instructions in TableGen format.
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Instruction format superclass
//===----------------------------------------------------------------------===//

include "AVRInstrFormats.td"

//===----------------------------------------------------------------------===//
// AVR Type Profiles
//===----------------------------------------------------------------------===//

def SDT_AVRCallSeqStart : SDCallSeqStart<[SDTCisVT<0, i16>]>;
def SDT_AVRCallSeqEnd : SDCallSeqEnd<[SDTCisVT<0, i16>, SDTCisVT<1, i16>]>;
def SDT_AVRCall : SDTypeProfile<0, -1, [SDTCisVT<0, iPTR>]>;
def SDT_AVRWrapper : SDTypeProfile<1, 1, [SDTCisSameAs<0, 1>, SDTCisPtrTy<0>]>;
def SDT_AVRBrcond : SDTypeProfile<0, 2,
                                  [SDTCisVT<0, OtherVT>, SDTCisVT<1, i8>]>;
def SDT_AVRCmp : SDTypeProfile<0, 2, [SDTCisSameAs<0, 1>]>;
def SDT_AVRTst : SDTypeProfile<0, 1, [SDTCisInt<0>]>;
def SDT_AVRSelectCC : SDTypeProfile<1, 3, [SDTCisSameAs<0, 1>,
                                    SDTCisSameAs<1, 2>, SDTCisVT<3, i8>]>;

//===----------------------------------------------------------------------===//
// AVR Specific Node Definitions
//===----------------------------------------------------------------------===//

def AVRretflag : SDNode<"AVRISD::RET_FLAG", SDTNone,
                        [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
def AVRretiflag : SDNode<"AVRISD::RETI_FLAG", SDTNone,
                         [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;

def AVRcallseq_start : SDNode<"ISD::CALLSEQ_START", SDT_AVRCallSeqStart,
                              [SDNPHasChain, SDNPOutGlue]>;
def AVRcallseq_end : SDNode<"ISD::CALLSEQ_END", SDT_AVRCallSeqEnd,
                            [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;

def AVRcall : SDNode<"AVRISD::CALL", SDT_AVRCall,
                     [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue, SDNPVariadic]>;

def AVRWrapper : SDNode<"AVRISD::Wrapper", SDT_AVRWrapper>;

def AVRbrcond : SDNode<"AVRISD::BRCOND", SDT_AVRBrcond,
                       [SDNPHasChain, SDNPInGlue]>;
def AVRcmp : SDNode<"AVRISD::CMP", SDT_AVRCmp, [SDNPOutGlue]>;
def AVRcmpc : SDNode<"AVRISD::CMPC", SDT_AVRCmp, [SDNPInGlue, SDNPOutGlue]>;
def AVRtst : SDNode<"AVRISD::TST", SDT_AVRTst, [SDNPOutGlue]>;
def AVRselectcc: SDNode<"AVRISD::SELECT_CC", SDT_AVRSelectCC, [SDNPInGlue]>;

// shift nodes
def AVRlsl : SDNode<"AVRISD::LSL", SDTIntUnaryOp>;
def AVRlsr : SDNode<"AVRISD::LSR", SDTIntUnaryOp>;
def AVRrol : SDNode<"AVRISD::ROL", SDTIntUnaryOp>;
def AVRror : SDNode<"AVRISD::ROR", SDTIntUnaryOp>;
def AVRasr : SDNode<"AVRISD::ASR", SDTIntUnaryOp>;

// pseudo shift nodes for non-constant shift amounts
def AVRlslLoop : SDNode<"AVRISD::LSLLOOP", SDTIntShiftOp>;
def AVRlsrLoop : SDNode<"AVRISD::LSRLOOP", SDTIntShiftOp>;
def AVRasrLoop : SDNode<"AVRISD::ASRLOOP", SDTIntShiftOp>;

//===----------------------------------------------------------------------===//
// AVR Operands, Complex Patterns and Transformations Definitions.
//===----------------------------------------------------------------------===//

def imm8_neg_XFORM : SDNodeXForm<imm,
[{
  return CurDAG->getTargetConstant(-N->getAPIntValue(), MVT::i8);
}]>;

def imm16_neg_XFORM : SDNodeXForm<imm,
[{
  return CurDAG->getTargetConstant(-N->getAPIntValue(), MVT::i16);
}]>;

def imm0_63_neg : PatLeaf<(imm),
[{
  int64_t val = -N->getSExtValue();
  return val >= 0 && val < 64;
}], imm16_neg_XFORM>;

def uimm6 : PatLeaf<(imm), [{ return isUInt<6>(N->getZExtValue()); }]>;

def ioaddr_XFORM : SDNodeXForm<imm,
[{
  return CurDAG->getTargetConstant(uint8_t(N->getZExtValue()) - 0x20, MVT::i8);
}]>;

def iobitpos8_XFORM : SDNodeXForm<imm,
[{
  return CurDAG->getTargetConstant(Log2_32(uint8_t(N->getZExtValue())),
                                   MVT::i8);
}]>;

def iobitposn8_XFORM : SDNodeXForm<imm,
[{
  return CurDAG->getTargetConstant(Log2_32(uint8_t(~N->getZExtValue())),
                                   MVT::i8);
}]>;

def ioaddr8 : PatLeaf<(imm),
[{
  uint64_t val = N->getZExtValue();
  return val >= 0x20 && val < 0x60;
}], ioaddr_XFORM>;

def lowioaddr8 : PatLeaf<(imm),
[{
  uint64_t val = N->getZExtValue();
  return val >= 0x20 && val < 0x40;
}], ioaddr_XFORM>;

def ioaddr16 : PatLeaf<(imm),
[{
  uint64_t val = N->getZExtValue();
  return val >= 0x20 && val < 0x5f;
}], ioaddr_XFORM>;

def iobitpos8 : PatLeaf<(imm),
[{
  return isPowerOf2_32(uint8_t(N->getZExtValue()));
}], iobitpos8_XFORM>;

def iobitposn8 : PatLeaf<(imm),
[{
  return isPowerOf2_32(uint8_t(~N->getZExtValue()));
}], iobitposn8_XFORM>;

// Address operand for reg+imm
def memri : Operand<iPTR>
{
  let PrintMethod = "printMemriOperand";
  let EncoderMethod = "getMemriEncoding";
  
  let MIOperandInfo = (ops PTRDISPREGS, i8imm);
}

// Address operand for SP+imm used by STD{W}SPQRr
def memspi : Operand<iPTR>
{
  let MIOperandInfo = (ops GPRSP, i16imm);
}

// Branch targets have OtherVT type and print as pc-relative values.
def brtarget : Operand<OtherVT>
{
  let PrintMethod = "print_pcrel_imm";
  let EncoderMethod = "getBreakTargetEncoding";
}

// Addressing mode pattern reg+imm6
def addr : ComplexPattern<iPTR, 2, "SelectAddr", [], [SDNPWantRoot]>;

// AVR specific condition code. These correspond to AVR_*_COND in
// AVRInstrInfo.td. They must be kept in synch.
def AVR_COND_EQ : PatLeaf<(i8 0)>;
def AVR_COND_NE : PatLeaf<(i8 1)>;
def AVR_COND_GE : PatLeaf<(i8 2)>;
def AVR_COND_LT : PatLeaf<(i8 3)>;
def AVR_COND_SH : PatLeaf<(i8 4)>;
def AVR_COND_LO : PatLeaf<(i8 5)>;
def AVR_COND_MI : PatLeaf<(i8 6)>;
def AVR_COND_PL : PatLeaf<(i8 7)>;


//__________________________________________________________________________________________
//__________________________________________________________________________________________
//__________________________________________________________________________________________
//__________________________________________________________________________________________
//__________________________________________________________________________________________
//__________________________________________________________________________________________
//__________________________________________________________________________________________
//__________________________________________________________________________________________

//===----------------------------------------------------------------------===//
// AVR Instruction list
//===----------------------------------------------------------------------===//

// ADJCALLSTACKDOWN/UP implicitly use/def SP because they may be expanded into
// a stack adjustment and the codegen must know that they may modify the stack
// pointer before prolog-epilog rewriting occurs.
// Pessimistically assume ADJCALLSTACKDOWN / ADJCALLSTACKUP will become
// sub / add which can clobber SREG.
let Defs = [SP, SREG],
Uses = [SP] in
{
def ADJCALLSTACKDOWN : Pseudo<(outs),
                              (ins i16imm:$amt),
                              "#ADJCALLSTACKDOWN",
                              [(AVRcallseq_start timm:$amt)]>;

// R31R30 is used to update SP, since it is a scratch reg and this instruction
// is placed after the function call then R31R30 should be always free.
//let Defs = [R31R30],
//Uses = [R31R30] in
//:TODO: if we enable this, the pseudo is killed because it looks dead
def ADJCALLSTACKUP : Pseudo<(outs),
                            (ins i16imm:$amt1, i16imm:$amt2),
                            "#ADJCALLSTACKUP",
                            [(AVRcallseq_end timm:$amt1, timm:$amt2)]>;
}

// Arithmetic instructions

// ADD Rd, Rr
// Adds two 8-bit registers.
let isCommutable = 1,
Constraints = "$src = $dst",
Defs = [SREG] in
def ADDRdRr : FRdRr<0b0000,
                    0b11,
                    (outs GPR8:$dst),
                    (ins GPR8:$src, GPR8:$src2),
                    "add\t$dst, $src2",
                    [(set GPR8:$dst, (add GPR8:$src, GPR8:$src2)),
                     (implicit SREG)]>;

// ADDW Rd, Rr
// Pseudo instruction to add four 8-bit registers as two 16-bit values.
let isCommutable = 1,
Constraints = "$src = $dst",
Defs = [SREG] in
def ADDWRdRr : Pseudo<(outs DREGS:$dst),
                      (ins DREGS:$src, DREGS:$src2),
                      "addw\t$dst, $src2",
                      [(set DREGS:$dst, (add DREGS:$src, DREGS:$src2)),
                       (implicit SREG)]>;

// ADC Rd, Rr
// Adds two 8-bit registers with carry.
let isCommutable = 1,
Constraints = "$src = $dst",
Uses = [SREG],
Defs = [SREG] in
def ADCRdRr : FRdRr<0b0001,
                    0b11,
                    (outs GPR8:$dst),
                    (ins GPR8:$src, GPR8:$src2),
                    "adc\t$dst, $src2",
                    [(set GPR8:$dst, (adde GPR8:$src, GPR8:$src2)),
                     (implicit SREG)]>;

// ADCW Rd, Rr
// Pseudo instruction to add four 8-bit registers as two 16-bit values with carry.
let isCommutable = 1,
Constraints = "$src = $dst",
Uses = [SREG],
Defs = [SREG] in
def ADCWRdRr : Pseudo<(outs DREGS:$dst),
                      (ins DREGS:$src, DREGS:$src2),
                      "adcw\t$dst, $src2",
                      [(set DREGS:$dst, (adde DREGS:$src, DREGS:$src2)),
                       (implicit SREG)]>;

// AIDW Rd, k
// Adds an immediate 6-bit value K to Rd, placing the result in Rd.
let Constraints = "$src = $dst",
Defs = [SREG] in
def ADIWRdK : FWRdK<0b0,
                    (outs IWREGS:$dst),
                    (ins IWREGS:$src, i16imm:$k),
                    "adiw\t$dst, $k",
                    [(set IWREGS:$dst, (add IWREGS:$src, uimm6:$k)),
                     (implicit SREG)]>;

// SUB Rd, Rr
// Subtracts the 8-bit value of Rr from Rd and places the value in Rd.
let Constraints = "$src = $dst",
Defs = [SREG] in
def SUBRdRr : FRdRr<0b0001,
                    0b10,
                    (outs GPR8:$dst),
                    (ins GPR8:$src, GPR8:$src2),
                    "sub\t$dst, $src2",
                    [(set GPR8:$dst, (sub GPR8:$src, GPR8:$src2)),
                     (implicit SREG)]>;

// SUBW Rd, Rr
// Subtracts two 16-bit values and places the result into Rd.
let Constraints = "$src = $dst",
Defs = [SREG] in
def SUBWRdRr : Pseudo<(outs DREGS:$dst),
                      (ins DREGS:$src, DREGS:$src2),
                      "subw\t$dst, $src2",
                      [(set DREGS:$dst, (sub DREGS:$src, DREGS:$src2)),
                       (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def SUBIRdK : FRdK<0b0101,
                   (outs LD8:$dst),
                   (ins LD8:$src, i8imm:$src2),
                   "subi\t$dst, $src2",
                   [(set LD8:$dst, (sub LD8:$src, imm:$src2)),
                    (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def SUBIWRdK : Pseudo<(outs DLDREGS:$dst),
                      (ins DLDREGS:$src, i16imm:$src2),
                      "subiw\t$dst, $src2",
                      [(set DLDREGS:$dst, (sub DLDREGS:$src, imm:$src2)),
                       (implicit SREG)]>;

let Constraints = "$src = $dst",
Uses = [SREG],
Defs = [SREG] in
def SBCRdRr : FRdRr<0b0000,
                    0b10,
                    (outs GPR8:$dst),
                    (ins GPR8:$src, GPR8:$src2),
                    "sbc\t$dst, $src2",
                    [(set GPR8:$dst, (sube GPR8:$src, GPR8:$src2)),
                     (implicit SREG)]>;

let Constraints = "$src = $dst",
Uses = [SREG],
Defs = [SREG] in
def SBCWRdRr : Pseudo<(outs DREGS:$dst),
                      (ins DREGS:$src, DREGS:$src2),
                      "sbcw\t$dst, $src2",
                      [(set DREGS:$dst, (sube DREGS:$src, DREGS:$src2)),
                       (implicit SREG)]>;

let Constraints = "$src = $dst",
Uses = [SREG],
Defs = [SREG] in
def SBCIRdK : FRdK<0b0100,
                   (outs LD8:$dst),
                   (ins LD8:$src, i8imm:$src2),
                   "sbci\t$dst, $src2",
                   [(set LD8:$dst, (sube LD8:$src, imm:$src2)),
                    (implicit SREG)]>;

let Constraints = "$src = $dst",
Uses = [SREG],
Defs = [SREG] in
def SBCIWRdK : Pseudo<(outs DLDREGS:$dst),
                      (ins DLDREGS:$src, i16imm:$src2),
                      "sbciw\t$dst, $src2",
                      [(set DLDREGS:$dst, (sube DLDREGS:$src, imm:$src2)),
                       (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def SBIWRdK : FWRdK<0b1,
                    (outs IWREGS:$dst),
                    (ins IWREGS:$src, i16imm:$k),
                    "sbiw\t$dst, $k",
                    [(set IWREGS:$dst, (sub IWREGS:$src, uimm6:$k)),
                     (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def INCRd : FRd<0b1001,
                0b0100011,
                (outs GPR8:$dst),
                (ins GPR8:$src),
                "inc\t$dst",
                [(set GPR8:$dst, (add GPR8:$src, 1)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def DECRd : FRd<0b1001,
                0b0101010,
                (outs GPR8:$dst),
                (ins GPR8:$src),
                "dec\t$dst",
                [(set GPR8:$dst, (add GPR8:$src, -1)), (implicit SREG)]>;

// This pseudo is used as a marker to insert a "clr r1" after the operation.
let isCommutable = 1,
Defs = [R1, R0, SREG] in
def MULRdRrP : Pseudo<(outs GPR8:$dst),
                      (ins GPR8:$src, GPR8:$src2),
                      "mulp\t$dst, $src, $src2",
                      [(set GPR8:$dst, (mul GPR8:$src, GPR8:$src2)),
                       (implicit SREG)]>;

// MUL Rd, Rr
// Multiplies Rd by Rr and places the result into Rd.
let isCommutable = 1,
Defs = [R1, R0, SREG],
hasSideEffects = 0 in
def MULRdRr : Mu1RdRr<(outs GPR8:$dst),
                      (ins GPR8:$src, GPR8:$src2),
                      "mul\t$src, $src2",
                      []>;

// The earlyclobber flag is required because the pseudo expansion needs $dst
// and $src to have different registers.
let isCommutable = 1,
Constraints = "@earlyclobber $dst",
Defs = [R1, R0, SREG] in
def MULWRdRr : Pseudo<(outs DREGS:$dst),
                      (ins DREGS:$src, DREGS:$src2),
                      "mulw\t$dst, $src, $src2",
                      [(set DREGS:$dst, (mul DREGS:$src, DREGS:$src2)),
                       (implicit SREG)]>;

// This instruction produces a 16bit result from two 8bit operands.
let isCommutable = 1,
Defs = [R1R0, SREG],
hasSideEffects = 0 in
def MUL16RdRr : Mu1RdRr<(outs DREGS:$dst),
                        (ins GPR8:$src, GPR8:$src2),
                        "mul\t$src, $src2",
                        []>;

//_______________________________________
// Logic Instructions
//_______________________________________

/// AND Rd, Rr
let isCommutable = 1,
Constraints = "$src = $dst",
Defs = [SREG] in
def ANDRdRr : FRdRr<0b0010,
                    0b00,
                    (outs GPR8:$dst),
                    (ins GPR8:$src, GPR8:$src2),
                    "and\t$dst, $src2",
                    [(set GPR8:$dst, (and GPR8:$src, GPR8:$src2)),
                     (implicit SREG)]>;

let isCommutable = 1,
Constraints = "$src = $dst",
Defs = [SREG] in
def ANDWRdRr : Pseudo<(outs DREGS:$dst),
                      (ins DREGS:$src, DREGS:$src2),
                      "andw\t$dst, $src2",
                      [(set DREGS:$dst, (and DREGS:$src, DREGS:$src2)),
                       (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def ANDIRdK : FRdK<0b0111,
                   (outs LD8:$dst),
                   (ins LD8:$src, i8imm:$src2),
                   "andi\t$dst, $src2",
                   [(set LD8:$dst, (and LD8:$src, imm:$src2)),
                    (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def ANDIWRdK : Pseudo<(outs DLDREGS:$dst),
                      (ins DLDREGS:$src, i16imm:$src2),
                      "andiw\t$dst, $src2",
                      [(set DLDREGS:$dst, (and DLDREGS:$src, imm:$src2)),
                       (implicit SREG)]>;

let isCommutable = 1,
Constraints = "$src = $dst",
Defs = [SREG] in
def ORRdRr : FRdRr<0b0010,
                   0b10,
                   (outs GPR8:$dst),
                   (ins GPR8:$src, GPR8:$src2),
                   "or\t$dst, $src2",
                   [(set GPR8:$dst, (or GPR8:$src, GPR8:$src2)),
                    (implicit SREG)]>;

let isCommutable = 1,
Constraints = "$src = $dst",
Defs = [SREG] in
def ORWRdRr : Pseudo<(outs DREGS:$dst),
                     (ins DREGS:$src, DREGS:$src2),
                     "orw\t$dst, $src2",
                     [(set DREGS:$dst, (or DREGS:$src, DREGS:$src2)),
                      (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def ORIRdK : FRdK<0b0110,
                  (outs LD8:$dst),
                  (ins LD8:$src, i8imm:$src2),
                  "ori\t$dst, $src2",
                  [(set LD8:$dst, (or LD8:$src, imm:$src2)),
                   (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def ORIWRdK : Pseudo<(outs DLDREGS:$dst),
                     (ins DLDREGS:$src, i16imm:$src2),
                     "oriw\t$dst, $src2",
                     [(set DLDREGS:$dst, (or DLDREGS:$src, imm:$src2)),
                      (implicit SREG)]>;

let isCommutable = 1,
Constraints = "$src = $dst",
Defs = [SREG] in
def EORRdRr : FRdRr<0b0010,
                    0b01,
                    (outs GPR8:$dst),
                    (ins GPR8:$src, GPR8:$src2),
                    "eor\t$dst, $src2",
                    [(set GPR8:$dst, (xor GPR8:$src, GPR8:$src2)),
                     (implicit SREG)]>;

let isCommutable = 1,
Constraints = "$src = $dst",
Defs = [SREG] in
def EORWRdRr : Pseudo<(outs DREGS:$dst),
                      (ins DREGS:$src, DREGS:$src2),
                      "eorw\t$dst, $src2",
                      [(set DREGS:$dst, (xor DREGS:$src, DREGS:$src2)),
                       (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def COMRd : FRd<0b1001,
                0b0100000,
                (outs GPR8:$dst),
                (ins GPR8:$src),
                "com\t$dst",
                [(set GPR8:$dst, (not GPR8:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def COMWRd : Pseudo<(outs DREGS:$dst),
                    (ins DREGS:$src),
                    "comw\t$dst",
                    [(set DREGS:$dst, (not DREGS:$src)), (implicit SREG)]>;

//:TODO: optimize NEG for wider types
let Constraints = "$src = $dst",
Defs = [SREG] in
def NEGRd : FRd<0b1001,
                0b0100001,
                (outs GPR8:$dst),
                (ins GPR8:$src),
                "neg\t$dst",
                [(set GPR8:$dst, (ineg GPR8:$src)), (implicit SREG)]>;

let Defs = [SREG] in
def TSTRd : Pseudo<(outs),
                   (ins GPR8:$src),
                   "tst\t$src",
                   [(AVRtst GPR8:$src), (implicit SREG)]>;

// Branch instructions

let isBarrier = 1,
isBranch = 1,
isTerminator = 1 in
def RJMPk : Pseudo<(outs),
                   (ins brtarget:$target),
                   "rjmp\t$target",
                   [(br bb:$target)]>;

let isBranch = 1,
isTerminator = 1,
isBarrier = 1,
isIndirectBranch = 1,
Uses = [R31R30] in
def IJMP : FBR<0b1001010000001001,
               (outs),
               (ins),
               "ijmp",
               []>;

let isBarrier = 1,
isBranch = 1,
isTerminator = 1 in
def JMPk : F32BRk<0b110,
                  (outs),
                  (ins brtarget:$target),
                  "jmp\t$target",
                  []>;
                  
let isCall = 1 in
  // SP is marked as a use to prevent stack-pointer assignments that appear
  // immediately before calls from potentially appearing dead.
  let Uses = [SP, R31R30] in
  {
    def ICALL : FBR<0b1001010100001001,
                    (outs),
                    (ins variable_ops),
                    "icall",
                    []>;
  }


let isCall = 1 in
  // SP is marked as a use to prevent stack-pointer assignments that appear
  // immediately before calls from potentially appearing dead.
  let Uses = [SP] in
  {
    def CALLk : F32BRk<0b111,
                       (outs),
      //:TODO: the imm field can be either 16 or 22 bits in devices with more
      // than 64k of ROM, fix it once we support the largests devices.
                       (ins i16imm:$dst),
                       "call\t$dst",
                       [(AVRcall imm:$dst)]>;
  }

let isTerminator = 1,
isReturn = 1,
isBarrier = 1 in
def RET : FBR<0b1001010100001000,
              (outs),
              (ins),
              "ret",
              [(AVRretflag)]>;

let isTerminator = 1,
isReturn = 1,
isBarrier = 1 in
def RETI : FBR<0b1001010100011000,
               (outs),
               (ins),
               "reti",
               [(AVRretiflag)]>;

let Defs = [SREG] in
def CPRdRr : Pseudo<(outs),
                    (ins GPR8:$src, GPR8:$src2),
                    "cp\t$src, $src2",
                    [(AVRcmp GPR8:$src, GPR8:$src2), (implicit SREG)]>;

let Defs = [SREG] in
def CPWRdRr : Pseudo<(outs),
                     (ins DREGS:$src, DREGS:$src2),
                     "cpw\t$src, $src2",
                     [(AVRcmp DREGS:$src, DREGS:$src2), (implicit SREG)]>;

let Defs = [SREG],
Uses = [SREG] in
def CPCRdRr : Pseudo<(outs),
                     (ins GPR8:$src, GPR8:$src2),
                     "cpc\t$src, $src2",
                     [(AVRcmpc GPR8:$src, GPR8:$src2), (implicit SREG)]>;

let Defs = [SREG],
Uses = [SREG] in
def CPCWRdRr : Pseudo<(outs),
                      (ins DREGS:$src, DREGS:$src2),
                      "cpcw\t$src, $src2",
                      [(AVRcmpc DREGS:$src, DREGS:$src2), (implicit SREG)]>;

let isBranch = 1,
isTerminator = 1,
Uses = [SREG] in
def BREQk : FBRsk<0,
                  0b001,
                  (outs),
                  (ins brtarget:$target),
                  "breq\t$target",
                  [(AVRbrcond bb:$target, AVR_COND_EQ)]>;

let isBranch = 1,
isTerminator = 1,
Uses = [SREG] in
def BRNEk : FBRsk<1,
                  0b001,
                  (outs),
                  (ins brtarget:$target),
                  "brne\t$target",
                  [(AVRbrcond bb:$target, AVR_COND_NE)]>;


let isBranch = 1,
isTerminator = 1,
Uses = [SREG] in
def BRSHk : Pseudo<(outs),
                   (ins brtarget:$target),
                   "brsh\t$target",
                   [(AVRbrcond bb:$target, AVR_COND_SH)]>;

let isBranch = 1,
isTerminator = 1,
Uses = [SREG] in
def BRLOk : Pseudo<(outs),
                   (ins brtarget:$target),
                   "brlo\t$target",
                   [(AVRbrcond bb:$target, AVR_COND_LO)]>;

let isBranch = 1,
isTerminator = 1,
Uses = [SREG] in
def BRMIk : Pseudo<(outs),
                   (ins brtarget:$target),
                   "brmi\t$target",
                   [(AVRbrcond bb:$target, AVR_COND_MI)]>;

let isBranch = 1,
isTerminator = 1,
Uses = [SREG] in
def BRPLk : Pseudo<(outs),
                   (ins brtarget:$target),
                   "brpl\t$target",
                   [(AVRbrcond bb:$target, AVR_COND_PL)]>;

let isBranch = 1,
isTerminator = 1,
Uses = [SREG] in
def BRGEk : Pseudo<(outs),
                   (ins brtarget:$target),
                   "brge\t$target",
                   [(AVRbrcond bb:$target, AVR_COND_GE)]>;

let isBranch = 1,
isTerminator = 1,
Uses = [SREG] in
def BRLTk : Pseudo<(outs),
                   (ins brtarget:$target),
                   "brlt\t$target",
                   [(AVRbrcond bb:$target, AVR_COND_LT)]>;
// __________________________
// Data transfer instructions
// __________________________

let hasSideEffects = 0 in
def MOVRdRr : FRdRr<0b0010,
                    0b11,
                    (outs GPR8:$dst),
                    (ins GPR8:$src),
                    "mov\t$dst, $src",
                    []>;

let hasSideEffects = 0 in
def MOVWRdRr : FMOVWRdRr<(outs DREGS:$dst),
                         (ins DREGS:$src),
                         "movw\t$dst, $src",
                         []>;

let isReMaterializable = 1,
isAsCheapAsAMove = 1 in
def LDIRdK : FRdK<0b1110,
                  (outs LD8:$dst),
                  (ins i8imm:$src),
                  "ldi\t$dst, $src",
                  [(set LD8:$dst, imm:$src)]>;

let isReMaterializable = 1,
isAsCheapAsAMove = 1 in
def LDIWRdK : Pseudo<(outs DLDREGS:$dst),
                     (ins i16imm:$src),
                     "ldiw\t$dst, $src",
                     [(set DLDREGS:$dst, imm:$src)]>;

let canFoldAsLoad = 1,
isReMaterializable = 1 in
def LDSRdK : F32DM<0b0,
                   (outs GPR8:$dst),
                   (ins i16imm:$src),
                   "lds\t$dst, $src",
                   [(set GPR8:$dst, (load imm:$src))]>;

let canFoldAsLoad = 1,
isReMaterializable = 1 in
def LDSWRdK : Pseudo<(outs DREGS:$dst),
                     (ins i16imm:$src),
                     "ldsw\t$dst, $src",
                     [(set DREGS:$dst, (load imm:$src))]>;

let canFoldAsLoad = 1,
isReMaterializable = 1 in
def LDRdPtr : Pseudo<(outs GPR8:$dst),
                     (ins PTRREGS:$src),
                     "ld\t$dst, $src",
                     [(set GPR8:$dst, (load PTRREGS:$src))]>;

let canFoldAsLoad = 1,
isReMaterializable = 1,
Constraints = "@earlyclobber $dst" in
def LDWRdPtr : Pseudo<(outs DREGS:$dst),
                      (ins PTRDISPREGS:$src),
                      "ldw\t$dst, $src",
                      [(set DREGS:$dst, (load PTRDISPREGS:$src))]>;

let mayLoad = 1,
hasSideEffects = 0,
Constraints = "$src = $base_wb,@earlyclobber $dst,@earlyclobber $base_wb" in
def LDRdPtrPi : Pseudo<(outs GPR8:$dst, PTRREGS:$base_wb),
                       (ins PTRREGS:$src),
                       "ld\t$dst, $src+",
                       []>;

let mayLoad = 1,
hasSideEffects = 0,
Constraints = "$src = $base_wb,@earlyclobber $dst,@earlyclobber $base_wb" in
def LDWRdPtrPi : Pseudo<(outs DREGS:$dst, PTRREGS:$base_wb),
                        (ins PTRREGS:$src),
                        "ldw\t$dst, $src+",
                        []>;

let mayLoad = 1,
hasSideEffects = 0,
Constraints = "$src = $base_wb,@earlyclobber $dst,@earlyclobber $base_wb" in
def LDRdPtrPd : Pseudo<(outs GPR8:$dst, PTRREGS:$base_wb),
                       (ins PTRREGS:$src),
                       "ld\t$dst, -$src",
                       []>;

let mayLoad = 1,
hasSideEffects = 0,
Constraints = "$src = $base_wb,@earlyclobber $dst,@earlyclobber $base_wb" in
def LDWRdPtrPd : Pseudo<(outs DREGS:$dst, PTRREGS:$base_wb),
                        (ins PTRREGS:$src),
                        "ldw\t$dst, -$src",
                        []>;

let canFoldAsLoad = 1,
isReMaterializable = 1 in
def LDDRdPtrQ : Pseudo<(outs GPR8:$dst),
                       (ins memri:$src),
                       "ldd\t$dst, $src",
                       [(set GPR8:$dst, (load addr:$src))]>;

let canFoldAsLoad = 1,
isReMaterializable = 1,
Constraints = "@earlyclobber $dst" in
def LDDWRdPtrQ : Pseudo<(outs DREGS:$dst),
                        (ins memri:$src),
                        "lddw\t$dst, $src",
                        [(set DREGS:$dst, (load addr:$src))]>;

//:FIXME: remove this once PR13375 gets fixed
let canFoldAsLoad = 1,
isReMaterializable = 1,
mayLoad = 1,
hasSideEffects = 0 in
def LDDWRdYQ : Pseudo<(outs DREGS:$dst),
                      (ins memri:$src),
                      "lddw\t$dst, $src",
                      []>;

def STSKRr : Pseudo<(outs),
                    (ins i16imm:$dst, GPR8:$src),
                    "sts\t$dst, $src",
                    [(store GPR8:$src, imm:$dst)]>;

def STSWKRr : Pseudo<(outs),
                     (ins i16imm:$dst, DREGS:$src),
                     "stsw\t$dst, $src",
                     [(store DREGS:$src, imm:$dst)]>;

// ST P, Rr
// Stores the value of Rr into the location addressed by pointer P.
def STPtrRr : Pseudo<(outs),
                     (ins PTRREGS:$dst, GPR8:$src),
                     "st\t$dst, $src",
                     [(store GPR8:$src, PTRREGS:$dst)]>;

// STW P, Rr
// Stores the value of Rr into the location addressed by pointer P.
def STWPtrRr : Pseudo<(outs),
                      (ins PTRDISPREGS:$dst, DREGS:$src),
                      "stw\t$dst, $src",
                      [(store DREGS:$src, PTRDISPREGS:$dst)]>;

// ST P+, Rr
// Stores the value of Rr into the location addressed by pointer P.
// Post increments P.
let Constraints = "$dst = $base_wb,@earlyclobber $base_wb" in
def STPtrPiRr : Pseudo<(outs PTRREGS:$base_wb),
                       (ins PTRREGS:$dst, GPR8:$src, i8imm:$offs),
                       "st\t$dst+, $src",
                       [(set PTRREGS:$base_wb,
                        (post_store GPR8:$src, PTRREGS:$dst, imm:$offs))]>;

// STW P+, Rr
// Stores the value of Rr into the location addressed by pointer P.
// Post increments P.
let Constraints = "$dst = $base_wb,@earlyclobber $base_wb" in
def STWPtrPiRr : Pseudo<(outs PTRREGS:$base_wb),
                        (ins PTRREGS:$dst, DREGS:$src, i8imm:$offs),
                        "stw\t$dst+, $src",
                        [(set PTRREGS:$base_wb,
                         (post_store DREGS:$src, PTRREGS:$dst, imm:$offs))]>;

// ST -P, Rr
// Stores the value of Rr into the location addressed by pointer P.
// Pre decrements P.
let Constraints = "$dst = $base_wb,@earlyclobber $base_wb" in
def STPtrPdRr : Pseudo<(outs PTRREGS:$base_wb),
                       (ins PTRREGS:$dst, GPR8:$src, i8imm:$offs),
                       "st\t-$dst, $src",
                       [(set PTRREGS:$base_wb,
                        (pre_store GPR8:$src, PTRREGS:$dst, imm:$offs))]>;

// STW -P, Rr
// Stores the value of Rr into the location addressed by pointer P.
// Pre decrements P.
let Constraints = "$dst = $base_wb,@earlyclobber $base_wb" in
def STWPtrPdRr : Pseudo<(outs PTRREGS:$base_wb),
                        (ins PTRREGS:$dst, DREGS:$src, i8imm:$offs),
                        "stw\t-$dst, $src",
                        [(set PTRREGS:$base_wb,
                         (pre_store DREGS:$src, PTRREGS:$dst, imm:$offs))]>;

/// STD P+q, Rr
// Stores the value of Rr into the location addressed by pointer P with a displacement of q.
// Does not modify P.
def STDPtrQRr : FSTDPqRr<(outs),
                       (ins memri:$dst, GPR8:$src),
                       "std\t$dst, $src",
                       [(store GPR8:$src, addr:$dst)]>;
/// STDW P+q, Rr
// Stores the value of Rr into the location addressed by pointer P with a displacement of q.
// Does not modify P.
def STDWPtrQRr : Pseudo<(outs),
                        (ins memri:$dst, DREGS:$src),
                        "stdw\t$dst, $src",
                        [(store DREGS:$src, addr:$dst)]>;

let canFoldAsLoad = 1,
isReMaterializable = 1,
hasSideEffects = 0 in
def LPMRdZ : Pseudo<(outs GPR8:$dst),
                    (ins),
                    "lpm\t$dst, Z",
                    []>;

let canFoldAsLoad = 1,
isReMaterializable = 1,
hasSideEffects = 0,
Constraints = "$src = $base_wb,@earlyclobber $dst,@earlyclobber $base_wb" in
def LPMWRdZ : Pseudo<(outs DREGS:$dst, DREGS:$base_wb),
                     (ins DREGS:$src),
                     "lpmw\t$dst, Z",
                     []>;

let mayLoad = 1,
hasSideEffects = 0,
Constraints = "$src = $base_wb,@earlyclobber $dst,@earlyclobber $base_wb" in
def LPMRdZPi : Pseudo<(outs GPR8:$dst, DREGS:$base_wb),
                      (ins DREGS:$src),
                      "lpm\t$dst, Z+",
                      []>;

let mayLoad = 1,
hasSideEffects = 0,
Constraints = "$src = $base_wb,@earlyclobber $dst,@earlyclobber $base_wb" in
def LPMWRdZPi : Pseudo<(outs DREGS:$dst, DREGS:$base_wb),
                       (ins DREGS:$src),
                       "lpmw\t$dst, Z+",
                       []>;

let canFoldAsLoad = 1,
isReMaterializable = 1 in
def INRdA : FIORdA<(outs GPR8:$dst),
                   (ins i16imm:$src),
                   "in\t$dst, $src",
                   [(set GPR8:$dst, (load ioaddr8:$src))]>;

let canFoldAsLoad = 1,
isReMaterializable = 1 in
def INWRdA : Pseudo<(outs DREGS:$dst),
                    (ins i16imm:$src),
                    "inw\t$dst, $src",
                    [(set DREGS:$dst, (load ioaddr16:$src))]>;

def OUTARr : FIOARr<(outs),
                    (ins i16imm:$dst, GPR8:$src),
                    "out\t$dst, $src",
                    [(store GPR8:$src, ioaddr8:$dst)]>;

def OUTWARr : Pseudo<(outs),
                     (ins i16imm:$dst, DREGS:$src),
                     "outw\t$dst, $src",
                     [(store DREGS:$src, ioaddr16:$dst)]>;

let Defs = [SP],
Uses = [SP],
hasSideEffects = 0,
mayStore = 1 in
def PUSHRr : FRd<0b1001,
                 0b0011111,
                 (outs),
                 (ins GPR8:$reg),
                 "push\t$reg",
                 []>;

let Defs = [SP],
Uses = [SP],
hasSideEffects = 0,
mayStore = 1 in
def PUSHWRr : Pseudo<(outs),
                     (ins DREGS:$reg),
                     "pushw\t$reg",
                     []>;

let Defs = [SP],
Uses = [SP],
hasSideEffects = 0,
mayLoad = 1 in
def POPRd : FRd<0b1001,
                0b0001111,
                (outs GPR8:$reg),
                (ins),
                "pop\t$reg",
                []>;

let Defs = [SP],
Uses = [SP],
hasSideEffects = 0,
mayLoad = 1 in
def POPWRd : Pseudo<(outs DREGS:$reg),
                    (ins),
                    "popw\t$reg",
                    []>;

// _______________________________
// Bit and bit-test instructions
// _______________________________

let Constraints = "$src = $dst",
Defs = [SREG] in
def LSLRd : FRdRr<0b0000,
                  0b11,
                  (outs GPR8:$dst),
                  (ins GPR8:$src),
                  "lsl\t$dst",
                  [(set GPR8:$dst, (AVRlsl GPR8:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def LSLWRd : Pseudo<(outs DREGS:$dst),
                    (ins DREGS:$src),
                    "lslw\t$dst",
                    [(set DREGS:$dst, (AVRlsl DREGS:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def LSRRd : FRd<0b1001,
                0b0100110,
                (outs GPR8:$dst),
                (ins GPR8:$src),
                "lsr\t$dst",
                [(set GPR8:$dst, (AVRlsr GPR8:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def LSRWRd : Pseudo<(outs DREGS:$dst),
                    (ins DREGS:$src),
                    "lsrw\t$dst",
                    [(set DREGS:$dst, (AVRlsr DREGS:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG],
Uses = [SREG] in
def ROLRd : FRdRr<0b0001,
                  0b11,
                  (outs GPR8:$dst),
                  (ins GPR8:$src),
                  "rol\t$dst",
                  [(set GPR8:$dst, (AVRrol GPR8:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG],
Uses = [SREG] in
def ROLWRd : Pseudo<(outs DREGS:$dst),
                    (ins DREGS:$src),
                    "rolw\t$dst",
                    [(set DREGS:$dst, (AVRrol DREGS:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG],
Uses = [SREG] in
def RORRd : FRd<0b1001,
                0b0100111,
                (outs GPR8:$dst),
                (ins GPR8:$src),
                "ror\t$dst",
                [(set GPR8:$dst, (AVRror GPR8:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG],
Uses = [SREG] in
def RORWRd : Pseudo<(outs DREGS:$dst),
                    (ins DREGS:$src),
                    "rorw\t$dst",
                    [(set DREGS:$dst, (AVRror DREGS:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def ASRRd : FRd<0b1001,
                0b0100101,
                (outs GPR8:$dst),
                (ins GPR8:$src),
                "asr\t$dst",
                [(set GPR8:$dst, (AVRasr GPR8:$src)), (implicit SREG)]>;

let Constraints = "$src = $dst",
Defs = [SREG] in
def ASRWRd : Pseudo<(outs DREGS:$dst),
                    (ins DREGS:$src),
                    "asrw\t$dst",
                    [(set DREGS:$dst, (AVRasr DREGS:$src)), (implicit SREG)]>;

//:TODO: add 16 bit and wider version of this
let Constraints = "$src = $dst" in
def SWAPRd : FRd<0b1001,
                 0b0100010,
                 (outs GPR8:$dst),
                 (ins GPR8:$src),
                 "swap\t$dst",
                 [(set GPR8:$dst, (bswap GPR8:$src))]>;

//:TODO: add 16 bit versions of cbi/sbi
//:TODO: add patterns when popcount(imm)==2 to be expanded with 2 sbi/cbi
// instead of in+ori+out which requires one more instr.
def SBIAb : Pseudo<(outs),
                   (ins i16imm:$addr, i8imm:$bit),
                   "sbi\t$addr, $bit",
                   [(store (or (i8 (load lowioaddr8:$addr)), iobitpos8:$bit),
                     lowioaddr8:$addr)]>;

def CBIAb : Pseudo<(outs),
                   (ins i16imm:$addr, i8imm:$bit),
                   "cbi\t$addr, $bit",
                   [(store (and (i8 (load lowioaddr8:$addr)), iobitposn8:$bit),
                     lowioaddr8:$addr)]>;

def SEI : FI<0b1001010001111000,
               (outs),
               (ins),
               "cli",
               []>;

def CLI : FI<0b1001010011111000,
               (outs),
               (ins),
               "cli",
               []>;

//===----------------------------------------------------------------------===//
// Pseudo instructions for later expansion
//===----------------------------------------------------------------------===//

//:TODO: optimize this for wider types AND optimize the following code
//   compile int foo(char a, char b, char c, char d) {return d+b;}
//   looks like a missed sext_inreg opportunity
let Defs = [SREG] in
def SEXT : Pseudo<(outs DREGS:$dst),
                  (ins GPR8:$src),
                  "sext\t$dst, $src",
                  [(set DREGS:$dst, (sext GPR8:$src)), (implicit SREG)]>;

let Defs = [SREG] in
def ZEXT : Pseudo<(outs DREGS:$dst),
                  (ins GPR8:$src),
                  "zext\t$dst, $src",
                  [(set DREGS:$dst, (zext GPR8:$src)), (implicit SREG)]>;

// This pseudo gets expanded into a movw+adiw thus it clobbers SREG.
let Defs = [SREG],
hasSideEffects = 0 in
def FRMIDX : Pseudo<(outs DLDREGS:$dst),
                    (ins DLDREGS:$src, i16imm:$src2),
                    "frmidx\t$dst, $src, $src2",
                    []>;

// This pseudo is either converted to a regular store or a push which clobbers
// SP.
let Defs = [SP] in
def STDSPQRr : Pseudo<(outs),
                      (ins memspi:$dst, GPR8:$src),
                      "stdstk\t$dst, $src",
                      [(store GPR8:$src, addr:$dst)]>;

// This pseudo is either converted to a regular store or a push which clobbers
// SP.
let Defs = [SP] in
def STDWSPQRr : Pseudo<(outs),
                       (ins memspi:$dst, DREGS:$src),
                       "stdwstk\t$dst, $src",
                       [(store DREGS:$src, addr:$dst)]>;

let Uses = [SP],
hasSideEffects = 0 in
def SPREAD : Pseudo<(outs DREGS:$dst),
                    (ins GPRSP:$src),
                    "spread\t$dst, $src",
                    []>;

let Defs = [SP],
hasSideEffects = 0 in
def SPWRITE : Pseudo<(outs GPRSP:$dst),
                     (ins DREGS:$src),
                     "spwrite\t$dst, $src",
                     []>;

let usesCustomInserter = 1 in
{
  let Uses = [SREG] in
  def Select8 : Pseudo<(outs GPR8:$dst),
                       (ins GPR8:$src, GPR8:$src2, i8imm:$cc),
                       "# Select8 PSEUDO",
                       [(set GPR8:$dst,
                        (AVRselectcc GPR8:$src, GPR8:$src2, imm:$cc))]>;
  let Uses = [SREG] in
  def Select16 : Pseudo<(outs DREGS:$dst),
                        (ins DREGS:$src, DREGS:$src2, i8imm:$cc),
                        "# Select16 PSEUDO",
                        [(set DREGS:$dst,
                         (AVRselectcc DREGS:$src, DREGS:$src2, imm:$cc))]>;

  let Defs = [SREG] in
  def Lsl8 : Pseudo<(outs GPR8:$dst),
                    (ins GPR8:$src, GPR8:$cnt),
                    "# Lsl8 PSEUDO",
                    [(set GPR8:$dst, (AVRlslLoop GPR8:$src, GPR8:$cnt))]>;
  let Defs = [SREG] in
  def Lsl16 : Pseudo<(outs DREGS:$dst),
                     (ins DREGS:$src, GPR8:$cnt),
                     "# Lsl16 PSEUDO",
                     [(set DREGS:$dst, (AVRlslLoop DREGS:$src, GPR8:$cnt))]>;

  let Defs = [SREG] in
  def Lsr8 : Pseudo<(outs GPR8:$dst),
                    (ins GPR8:$src, GPR8:$cnt),
                    "# Lsr8 PSEUDO",
                    [(set GPR8:$dst, (AVRlsrLoop GPR8:$src, GPR8:$cnt))]>;
  let Defs = [SREG] in
  def Lsr16 : Pseudo<(outs DREGS:$dst),
                     (ins DREGS:$src, GPR8:$cnt),
                     "# Lsr16 PSEUDO",
                     [(set DREGS:$dst, (AVRlsrLoop DREGS:$src, GPR8:$cnt))]>;

  let Defs = [SREG] in
  def Asr8 : Pseudo<(outs GPR8:$dst),
                    (ins GPR8:$src, GPR8:$cnt),
                    "# Asr8 PSEUDO",
                    [(set GPR8:$dst, (AVRasrLoop GPR8:$src, GPR8:$cnt))]>;
  let Defs = [SREG] in
  def Asr16 : Pseudo<(outs DREGS:$dst),
                     (ins DREGS:$src, GPR8:$cnt),
                     "# Asr16 PSEUDO",
                     [(set DREGS:$dst, (AVRasrLoop DREGS:$src, GPR8:$cnt))]>;
}

//===----------------------------------------------------------------------===//
// Non-Instruction Patterns
//===----------------------------------------------------------------------===//

//:TODO: look in x86InstrCompiler.td for odd encoding trick related to
// add x, 128 -> sub x, -128. Clang is emitting an eor for this (ldi+eor)

// the add instruction always writes the carry flag
def : Pat<(addc GPR8:$src, GPR8:$src2),
          (ADDRdRr GPR8:$src, GPR8:$src2)>;
def : Pat<(addc DREGS:$src, DREGS:$src2),
          (ADDWRdRr DREGS:$src, DREGS:$src2)>;

// all sub instruction variants always writes the carry flag
def : Pat<(subc GPR8:$src, GPR8:$src2),
          (SUBRdRr GPR8:$src, GPR8:$src2)>;
def : Pat<(subc DREGS:$src, DREGS:$src2),
          (SUBWRdRr DREGS:$src, DREGS:$src2)>;
def : Pat<(subc LD8:$src, imm:$src2),
          (SUBIRdK LD8:$src, imm:$src2)>;
def : Pat<(subc DLDREGS:$src, imm:$src2),
          (SUBIWRdK DLDREGS:$src, imm:$src2)>;

// these patterns convert add (x, -imm) to sub (x, imm) since we dont have
// any add with imm instructions. Also take care of the adiw/sbiw instructions
//:TODO: Use adiw/sbiw in 32/64 ops if the lower part is < 64 like
// int32var + 3 -> adiw R25:R24, 3; adc R26, 0; adc r27, 0
def : Pat<(add IWREGS:$src1, imm0_63_neg:$src2),
          (SBIWRdK IWREGS:$src1, (imm0_63_neg:$src2))>;
def : Pat<(add DLDREGS:$src1, imm:$src2),
          (SUBIWRdK DLDREGS:$src1, (imm16_neg_XFORM imm:$src2))>;
def : Pat<(addc DLDREGS:$src1, imm:$src2),
          (SUBIWRdK DLDREGS:$src1, (imm16_neg_XFORM imm:$src2))>;
def : Pat<(adde DLDREGS:$src1, imm:$src2),
          (SBCIWRdK DLDREGS:$src1, (imm16_neg_XFORM imm:$src2))>;

def : Pat<(add LD8:$src1, imm:$src2),
          (SUBIRdK LD8:$src1, (imm8_neg_XFORM imm:$src2))>;
def : Pat<(addc LD8:$src1, imm:$src2),
          (SUBIRdK LD8:$src1, (imm8_neg_XFORM imm:$src2))>;
def : Pat<(adde LD8:$src1, imm:$src2),
          (SBCIRdK LD8:$src1, (imm8_neg_XFORM imm:$src2))>;

// calls
def : Pat<(AVRcall (i16 tglobaladdr:$dst)),
          (CALLk tglobaladdr:$dst)>;
def : Pat<(AVRcall (i16 texternalsym:$dst)),
          (CALLk texternalsym:$dst)>;

// anyext
def : Pat<(i16 (anyext GPR8:$src)),
          (INSERT_SUBREG (i16 (IMPLICIT_DEF)), GPR8:$src, sub_lo)>;

// trunc
def : Pat<(i8 (trunc DREGS:$src)),
          (EXTRACT_SUBREG DREGS:$src, sub_lo)>;

// sext_inreg
def : Pat<(sext_inreg DREGS:$src, i8),
          (SEXT (i8 (EXTRACT_SUBREG DREGS:$src, sub_lo)))>;

// GlobalAddress
def : Pat<(i16 (AVRWrapper tglobaladdr:$dst)),
          (LDIWRdK tglobaladdr:$dst)>;
def : Pat<(add DREGS:$src, (AVRWrapper tglobaladdr:$src2)),
          (SUBIWRdK DREGS:$src, tglobaladdr:$src2)>;
def : Pat<(i8 (load (AVRWrapper tglobaladdr:$dst))),
          (LDSRdK tglobaladdr:$dst)>;
def : Pat<(i16 (load (AVRWrapper tglobaladdr:$dst))),
          (LDSWRdK tglobaladdr:$dst)>;
def : Pat<(store GPR8:$src, (i16 (AVRWrapper tglobaladdr:$dst))),
          (STSKRr tglobaladdr:$dst, GPR8:$src)>;
def : Pat<(store DREGS:$src, (i16 (AVRWrapper tglobaladdr:$dst))),
          (STSWKRr tglobaladdr:$dst, DREGS:$src)>;

// BlockAddress
def : Pat<(i16 (AVRWrapper tblockaddress:$dst)),
          (LDIWRdK tblockaddress:$dst)>;

// hi-reg truncation : trunc(int16 >> 8)
//:FIXME: i think it's better to emit an extract subreg node in the DAG than
// all this mess once we get optimal shift code
def : Pat<(i8 (trunc (AVRlsr (AVRlsr (AVRlsr (AVRlsr (AVRlsr (AVRlsr (AVRlsr
                     (AVRlsr DREGS:$src)))))))))),
          (EXTRACT_SUBREG DREGS:$src, sub_hi)>;

// :FIXME: DAGCombiner produces an shl node after legalization from these seq:
// BR_JT -> (mul x, 2) -> (shl x, 1)
def : Pat<(shl DREGS:$src1, (i8 1)),
          (LSLWRd DREGS:$src1)>;
